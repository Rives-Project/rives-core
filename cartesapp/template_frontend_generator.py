from pydantic2ts.cli.script import generate_json_schema
import os
import subprocess
import tempfile
from jinja2 import Template

def convert_camel_case(s):
    splitted = s.split('_')
    return splitted[0] + ''.join(i.title() for i in splitted[1:])

def render_templates(conf,settings,mutations_info,queries_info,notices_info,reports_info,modules_to_add):

    add_indexer_query = False
    for module_name in settings:
        if getattr(settings[module_name],'index_outputs'): 
            add_indexer_query = True
            break

    indexer_query_info = None
    indexer_output_info = None

    # print(conf,settings,mutations_info,queries_info,notices_info,reports_info,modules_to_add)

    modules = ['cartesapp'] 
    modules.extend(modules_to_add)
    modules_processed = []
    while len(modules_to_add) > 0:
        if 'cartesapp' not in modules_processed:
            module_name = 'cartesapp'
        else:
            module_name = modules_to_add.pop()
        modules_processed.append(module_name)

        module_notices_info = [i for i in notices_info.values() if i['module'] == module_name]
        module_reports_info = [i for i in reports_info.values() if i['module'] == module_name]
        module_mutations_info = [i for i in mutations_info.values() if i['module'] == module_name]
        module_queries_info = [i for i in queries_info.values() if i['module'] == module_name]

        models = []
        models.extend(map(lambda i:i['model'],module_notices_info))
        models.extend(map(lambda i:i['model'],module_reports_info))
        models.extend(map(lambda i:i['model'],module_mutations_info))
        models.extend(map(lambda i:i['model'],module_queries_info))

        if len(models) > 0:

            schema = generate_json_schema(models)

            frontend_lib_path = f"frontend/src/{module_name}"

            if not os.path.exists(frontend_lib_path):
                os.makedirs(frontend_lib_path)

            output_filepath = f"{frontend_lib_path}/ifaces.d.ts"

            schema_temp = tempfile.NamedTemporaryFile()
            schema_file = schema_temp.file
            schema_file_path = schema_temp.name

            with open(schema_file_path, "w") as f:
                f.write(schema)

            args = ["npx","json2ts"]
            args.extend(["-i",schema_file_path])
            args.extend(["-o",output_filepath])

            result = subprocess.run(args, capture_output=True, text=True)
            if result.returncode > 0:
                raise Exception("Error generating typescript interfaces")

            schema_temp.close()

        if module_name == 'cartesapp':
            # helper_template_file = open('templates/cartesapp-helpers.j2','r')
            # helper_template = helper_template_file.read()
            # helper_template_file.close()

            if not indexer_output_info:
                indexer_query_info = queries_info[f"{conf['indexer_query'].__module__.split('.')[0]}.{conf['indexer_query'].__name__}"]
                indexer_output_info = reports_info[f"{conf['indexer_output'].__module__.split('.')[0]}.{conf['indexer_output'].__name__}"]

            helper_template_output = Template(helper_template).render({
                "add_indexer_query": add_indexer_query,
                "indexer_output_info": indexer_output_info
            })

            helper_filepath = f"{frontend_lib_path}/cartesapp-helpers.ts"
            with open(helper_filepath, "w") as f:
                f.write(helper_template_output)

        else:
            # lib_template_file = open('templates/lib.j2','r')
            # lib_template = lib_template_file.read()
            # lib_template_file.close()

            module_setting = settings[module_name]
            has_indexer_query = getattr(module_setting,'index_outputs')

            lib_template_output = Template(lib_template).render({
                "mutations_info":module_mutations_info,
                "queries_info":module_queries_info,
                "notices_info":module_notices_info,
                "reports_info":module_reports_info,
                "convert_camel_case":convert_camel_case,
                "has_indexer_query": has_indexer_query,
                "indexer_query_info": indexer_query_info,
                "indexer_output_info": indexer_output_info
            })

            lib_filepath = f"{frontend_lib_path}/lib.ts"
            with open(lib_filepath, "w") as f:
                f.write(lib_template_output)


helper_template = '''/* eslint-disable */
/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import { Signer, ethers, ContractReceipt } from "ethers";
import { keys } from 'ts-transformer-keys';
import Ajv, { ValidateFunction } from "ajv"

import { 
    advanceInput, inspect, 
    AdvanceOutput, InspectOptions, AdvanceInputOptions,
    queryNotice, queryReport, queryVoucher
} from "cartesi-client";

{% if add_indexer_query -%}
import * as ifaces from "./ifaces";
{% endif %}


/**
 * Configs
 */

const ajv = new Ajv()
const abiCoder = new ethers.utils.AbiCoder();


/**
 * Models
 */

export enum IOType {
    report = "report",
    notice = "notice",
    mutationInput = "mutationInput",
    queryInput = "queryInput"
}

interface ModelInterface<T> {
    ioType: IOType
    abiTypes: Array<string>;
    decoder(data: string|Uint8Array): T,
    validator: ValidateFunction<T>;
}

export const models = {
    {% if add_indexer_query -%}
    IndexerOutput: {
        ioType:IOType.report,
        abiTypes:{{ indexer_output_info['abi_types'] }},
        decoder: decodeToIndexerOutput,
        validator: ajv.compile<ifaces.IndexerOutput>(JSON.parse('{{ indexer_output_info["model"].schema_json() }}'))
    },
    {% endif %}
};

export const outputGetters = {
    report: queryReport,
    notice: queryNotice,
    voucher: queryVoucher
}


{% if add_indexer_query -%}
/**
 * Model Decoders
 */

export function decodeTo{{ indexer_output_info['class'] }}(data: string|Uint8Array): ifaces.{{ indexer_output_info['class'] }} {
    return genericDecodeTo<ifaces.IndexerOutput>(data,models.{{ indexer_output_info['class'] }});
}


{% endif %}
/*
 * Helpers
 */

export function genericDecodeTo<T extends object>(data: string|Uint8Array,model: ModelInterface<T>): T {
    let dataObj: any;
    switch(model.ioType) {
        case IOType.notice: {
            const dataValues = abiCoder.decode(model.abiTypes,data);
            dataObj = {};
            for (const [i, key] of keys<T>().entries()) {
                dataObj[key] = dataValues[i];
            }
            break;
        }
        case IOType.report: {
            dataObj = JSON.parse(ethers.utils.toUtf8String(data));
            break;
        }
        default: {
            throw new Error(`Cannot convert ${model.ioType}`);
            // break;
        }
    }
    if (!model.validator(dataObj))
        throw new Error(`Data does not comply to interface`);

    return dataObj;
}


export async function genericInspect<T>(
    inputData: T,
    route: string,
    options?:InspectOptions
):Promise<string|Uint8Array> {
    if (options == undefined) options = {};
    options.aggregate = true;

    // parametrize input to url
    const paramList = Array<string>();
    for (const key in inputData) {
        if (Array.isArray(inputData[key])) {
            for (const element in inputData[key]) {
                paramList.push(`${key}=${element}`);
            }
        } else {
            paramList.push(`${key}=${inputData[key]}`);
        }
    }
    let params = paramList.length > 0 ? `?${paramList.join('&')}` : "";
    const payload = `${route}${params}`

    const output = await inspect(payload,options);

    return output;
}

export async function genericAdvanceInput<T>(
    client:Signer,
    dappAddress:string,
    inputData: T,
    abiTypes: Array<string>,
    options?:AdvanceInputOptions
):Promise<AdvanceOutput|ContractReceipt> {
    if (options == undefined) options = {};

    const paramList = Array<any>();
    for (const key in inputData) {
        paramList.push(inputData[key]);
    }
    const payloadHex = abiCoder.encode(abiTypes,paramList);
    const output = await advanceInput(client,dappAddress,payloadHex,options);

    return output;
}
'''

lib_template = '''/* eslint-disable */
/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import { Signer, ContractReceipt } from "ethers";
import Ajv from "ajv"

import { AdvanceOutput, AdvanceInputOptions, InspectOptions, GraphqlOptions } from "cartesi-client";

import { 
    genericAdvanceInput, genericDecodeTo, genericInspect, 
    IOType, outputGetters{% if has_indexer_query -%}, decodeTo{{ indexer_output_info['model'].__name__ }}{% endif -%}
} from "../cartesapp/cartesapp-helpers"

{% if has_indexer_query -%}
import * as cartesappIfaces from "../cartesapp/ifaces"
{% endif -%}

import * as ifaces from "./ifaces";


/**
 * Configs
 */

const ajv = new Ajv()


/*
 * Mutations/Advances
 */

{% for info in mutations_info -%}
export async function {{ convert_camel_case(info['method']) }}(
    client:Signer,
    dappAddress:string,
    inputData: ifaces.{{ info['model'].__name__ }},
    options?:AdvanceInputOptions
):Promise<AdvanceOutput|ContractReceipt> {
    const abiTypes = {{ info['abi_types'] }};
    return genericAdvanceInput<ifaces.{{ info['model'].__name__ }}>(client,dappAddress,inputData,abiTypes,options);
}

{% endfor -%}

/*
 * Queries/Reports
 */

{% for info in queries_info -%}
export async function {{ convert_camel_case(info['method']) }}(
    inputData: ifaces.{{ info['model'].__name__ }},
    options?:InspectOptions
):Promise<string|Uint8Array> {
    const route = '{{ info["selector"] }}';
    return genericInspect<ifaces.{{ info['model'].__name__ }}>(inputData,route,options);
}

{% endfor -%}

{% if has_indexer_query -%}
/*
 * Indexer Query
 */

export async function getOutputs(: conditional indexer
    inputData: cartesappIfaces.{{ indexer_query_info['model'].__name__ }},
    options?:InspectOptions
):Promise<any[]> {
    if (options == undefined) options = {};
    const route = '{{ indexer_query_info["selector"] }}';
    const indexerOutputRaw = await genericInspect<cartesappIfaces.{{ indexer_query_info['model'].__name__ }}>(inputData,route,options);
    const indexerOutput: cartesappIfaces.{{ indexer_output_info['model'].__name__ }} = decodeTo{{ indexer_output_info['model'].__name__ }}(indexerOutputRaw);
    const graphqlQueries: Promise<any>[] = [];
    for (const outInd of indexerOutput.data) {
        const graphqlOptions: GraphqlOptions = {cartesiNodeUrl: options.cartesiNodeUrl, inputIndex: outInd.input_index, outputIndex: outInd.output_index};
        graphqlQueries.push(outputGetters[outInd.output_type](graphqlOptions).then(
            (output) => {
                return decodeToModel(output,outInd.class_name);
            }
        ));
    }
    return Promise.all(graphqlQueries);
}
{% endif -%}


/**
 * Models Decoders
 */

export function decodeToModel(data: string|Uint8Array, modelName: string): any {
    return models[modelName].decoder(data);
}

{% for info in notices_info -%}
export function decodeTo{{ info['class'] }}(data: string|Uint8Array): ifaces.{{ info['class'] }} {
    return genericDecodeTo<ifaces.{{ info['class'] }}>(data,models.{{ info['class'] }});
}

{% endfor -%}
{% for info in reports_info -%}
export function decodeTo{{ info['class'] }}(data: string|Uint8Array): ifaces.{{ info['class'] }} {
    return genericDecodeTo<ifaces.{{ info['class'] }}>(data,models.{{ info['class'] }});
}

{% endfor -%}

/**
 * Model
 */

export const models = {
    {% for info in reports_info -%}
    {{ info['class'] }}: {
        ioType:IOType.report,
        abiTypes:{{ info['abi_types'] }},
        decoder: decodeTo{{ info['class'] }},
        validator: ajv.compile<ifaces.{{ info['class'] }}>(JSON.parse('{{ info["model"].schema_json() }}'))
    },
    {% endfor -%}
    {% for info in notices_info -%}
    {{ info['class'] }}: {
        ioType:IOType.notice,
        abiTypes:{{ info['abi_types'] }},
        decoder: decodeTo{{ info['class'] }},
        validator: ajv.compile<ifaces.{{ info['class'] }}>(JSON.parse('{{ info["model"].schema_json() }}'))
    },
    {% endfor -%}
};
'''